# Binary Tree Dict

## Лабораторная работа №2

- **Студент:** Степутенко Илья Сергеевич
- **Группа:** P3312
- **ИСУ:** 368823

---

## Требования к разработанному ПО

1. **Реализовать структуру данных "Словарь" с использованием бинарного дерева.**
2. **Обеспечить основные операции:**
   - создание,
   - добавление,
   - удаление,
   - получение значения по ключу,
   - фильтрация,
   - отображение (map),
   - свертка (левая и правая),
   - объединение.
3. **Реализовать поведение (behaviour) для словаря.**
4. **Обеспечить тестирование, включая property-based тесты.**

## Ключевые элементы реализации

1. **Структура `BinaryTreeDict`:**

   - Представляет собой бинарное дерево поиска с узлами, содержащими ключ-значение.
   - Поддерживает неизменяемость данных, создавая новые деревья при каждой модификации.
   - Обеспечивает полиморфизм путем работы с различными типами ключей и значений.

2. **Основные функции:**

   - `new/0`: Создание нового пустого словаря.
   - `put/3`: Добавление или обновление пары ключ-значение.
   - `get/2`: Получение значения по заданному ключу.
   - `delete/2`: Удаление пары по ключу.
   - `filter/2`: Фильтрация элементов по предикату.
   - `map/2`: Применение функции к каждому значению.
   - `fold_left/3` и `fold_right/3`: Свертка элементов слева направо и справа налево.
   - `combine/2`: Объединение двух словарей.

3. **Поведение `DictBehaviour`:**

   - Определяет интерфейс для реализации словаря.
   - Обеспечивает стандартизацию функций и их контрактов.

4. **Тестирование:**

   - **Модульные тесты:** Проверка корректности каждой операции.
   - **Property-based тесты:** Проверка свойств моноида (ассоциативность, идентичность) и других инвариантов.

## Примеры использования

```elixir
# Создание нового словаря
dict = BinaryTreeDict.new()

# Добавление элементов
dict = BinaryTreeDict.put(dict, :a, 1)
dict = BinaryTreeDict.put(dict, :b, 2)
dict = BinaryTreeDict.put(dict, :c, 3)

# Получение значения по ключу
{:ok, value} = BinaryTreeDict.get(dict, :a)
# value = 1

# Обновление значения существующего ключа
dict = BinaryTreeDict.put(dict, :a, 10)
{:ok, updated_value} = BinaryTreeDict.get(dict, :a)
# updated_value = 10

# Удаление элемента
dict = BinaryTreeDict.delete(dict, :b)
{:error} = BinaryTreeDict.get(dict, :b)

# Фильтрация элементов
even_dict = BinaryTreeDict.filter(dict, fn _k, v -> rem(v, 2) == 0 end)

# Отображение элементов
doubled_dict = BinaryTreeDict.map(dict, fn _k, v -> v * 2 end)

# Свертка (сумма всех значений)
sum = BinaryTreeDict.fold_left(dict, 0, fn _k, v, acc -> acc + v end)
# sum = 13

# Объединение словарей
dict1 = BinaryTreeDict.new() |> BinaryTreeDict.put(:x, 100)
dict2 = BinaryTreeDict.new() |> BinaryTreeDict.put(:y, 200)
combined_dict = BinaryTreeDict.combine(dict1, dict2)

# Проверка на пустоту
is_empty = BinaryTreeDict.empty?(dict)

# Получение размера словаря
size = BinaryTreeDict.size(dict)

# Преобразование в список
list = BinaryTreeDict.to_list(dict)
# list = [a: 10, c: 3]
```

## Тесты и метрики

### Тесты

Реализованы следующие группы тестов:

- Создание словаря
- Добавление элементов
- Удаление элементов
- Получение значений
- Фильтрация
- Отображение
- Свертка (левая и правая)
- Объединение словарей
- Свойства моноида (ассоциативность, идентичность)

### Отчет инструмента тестирования

Для запуска тестов использовалась команда `mix test`. Все тесты прошли успешно.

### Метрики

```shell
> mix test
Compiling 2 files (.ex)
Generated binary_tree_dict app
Running ExUnit with seed: 123456

...................
Finished in 0.2 seconds (0.00s async, 0.2s sync)
3 properties, 16 tests, 0 failures
```

- **Производительность:** O(log n) для основных операций в среднем случае.
- **Использование памяти:** O(n), где n - количество элементов в словаре.

## Выводы

В ходе выполнения лабораторной работы были применены следующие приемы программирования:

1. **Функциональное программирование:** Использование функций высшего порядка (`map`, `filter`, `fold`).
2. **Иммутабельность данных:** Все операции создают новые структуры данных, не изменяя исходные.
3. **Паттерн проектирования "Поведение" (Behaviour):** Определение интерфейса для словаря через `DictBehaviour`.
4. **Property-based тестирование:** Использование StreamData для генерации тестовых данных и проверки свойств моноида.
5. **Модульное тестирование:** Детальные тесты для каждой функции и сценария использования.
